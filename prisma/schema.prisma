datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}



// model City {
//   id_city     Int       @id @default(autoincrement())
//   city        String
//   province    Province  @relation(fields: [id_province], references: [id_province])
//   id_province Int
//   Address     Address[]
// }

// model Province {
//   id_province Int     @id @default(autoincrement())
//   iso_code    String  @unique
//   province    String
//   country     Country @relation(fields: [id_country], references: [id_country])
//   id_country  Int
//   City        City[]
// }

// model Country {
//   id_country Int        @id @default(autoincrement())
//   iso_code   String     @unique
//   country    String
//   Province   Province[]
// }

model Province {
  id        String   @id
  nombre    String
  // Ciudades  Ciudad[]
}




// model Ciudad {
//   id          Int       @id @default(autoincrement())
//   nombre      String
//   ProvinciaId Int
//   Provincia   Provincia @relation(fields: [ProvinciaId], references: [id])
// }





model Product {
  id          Int       @id @default(autoincrement())
  name        String
  description String?
  state       String?
  price       Float     @default(0)
  discount    Int?      @default(0)
  material    String?
  created_at  DateTime  @default(now())
  last_update DateTime? @updatedAt

  
  // provider    Provider? @relation(fields: [id_provider], references: [id_provider])
  // id_provider Int?
  category    Category? @relation(fields: [id_category], references: [id])
  id_category Int?

  variants    ProductVariant[]
  ProductImage ProductImage[]
  OrderItem    OrderItem[]
}

model Color {
  id    Int    @id @default(autoincrement())
  name  String
  variants ProductVariant[]
}

model Size {
  id    Int    @id @default(autoincrement())
  value Int
  variants ProductVariant[]
}

model ProductVariant {
  id          Int       @id @default(autoincrement())
  code        String
  stock       Int
  productId   Int
  product     Product   @relation(fields: [productId], references: [id])
  colorId     Int
  color       Color     @relation(fields: [colorId], references: [id])
  sizeId      Int
  size        Size      @relation(fields: [sizeId], references: [id])
}

model ProductImage {
  id  Int    @id @default(autoincrement())
  url String

  product    Product @relation(fields: [id_product], references: [id])
  id_product Int
}

// model Image {
// id  Int    @id @default(autoincrement())
//   url String
  // altText?: string;
  // width?: number;
  // height?: number;
// }




model Category {
  id      Int       @id @default(autoincrement())
  name    String    @unique
  Product Product[]
}

// model Provider {
//   id_provider Int       @id @default(autoincrement())
//   cuit        String
//   name        String
//   address     Address?  @relation(fields: [id_address], references: [id])
//   id_address  Int?
//   postcode    String
//   phone       String?
//   email       String
//   created_at  DateTime  @default(now())
//   products    Product[]
// }

model Order {
  id         Int      @id @default(autoincrement())
  code       String   @unique
  type       String
  total      Float
  status     String
  paid       Boolean  @default(false)
  discount   Float    @default(0)
  created_at DateTime @default(now())

  user             User         @relation(fields: [id_user], references: [id])
  id_user          Int
  deliveryType     DeliveryType @relation(fields: [id_delivery_type], references: [id])
  id_delivery_type Int

  OrderItem OrderItem[]
  invoice   Invoice[]
}


model OrderItem {
  id         Int   @id @default(autoincrement())
  name       String
  quantity   Int
  unit_price Float

  Order      Order   @relation(fields: [id_order], references: [id])
  id_order   Int
  product    Product @relation(fields: [id_product], references: [id])
  id_product Int
}

model DeliveryType {
  id    Int     @id @default(autoincrement())
  name  String  @unique
  Order Order[]
}

model Invoice {
  id                Int           @id @default(autoincrement())
  invoice_n         String        @unique
  type              String
  Order             Order         @relation(fields: [id_order], references: [id])
  id_order          Int
  created_at        DateTime      @default(now())
  amount            Float
  state             String
  paymentMethod     PaymentMethod @relation(fields: [id_payment_method], references: [id])
  id_payment_method Int
}




//  SQLITE
// model User {
//   // id            String          @id @default(cuid())
//   id            Int       @id @default(autoincrement())
//   name          String
//   username      String?
//   bio           String?
//   email         String    @unique
//   emailVerified DateTime?
//   image         String?
//   role          String      @default("user")
//   phone         String?
//   password      String
//   address       Address?  @relation(fields: [id_address], references: [id])
//   id_address    Int?
//   postcode      String?
//   created_at    DateTime  @default(now())

//   accounts      Account[]
//   sessions      Session[]
//   // Optional for WebAuthn support
//   Authenticator Authenticator[]
//   Order         Order[]
// }
// model Address {
//   id          Int        @id @default(autoincrement())
//   name        String
//   number      Int
//   letter      String?
//   block       String?
//   staircase   String?
//   // city        City       @relation(fields: [id_city], references: [id_city])
//   // id_city     Int
//   last_update DateTime   @default(now()) @updatedAt
//   User        User[]
//   // Provider    Provider[]
// }
model User {
  id               Int          @id @default(autoincrement())
  name             String
  username         String?
  bio              String?
  email            String       @unique
  emailVerified    DateTime?
  image            String?
  role             String       @default("user")
  phone            String?
  password         String
  address          Address?     @relation(fields: [id_address], references: [id])
  id_address       Int?
  postcode         String?
  created_at       DateTime     @default(now())

  paymentMethods   PaymentMethod[]
  accounts         Account[]
  sessions         Session[]
  Authenticator    Authenticator[]
  Order            Order[]
}
model PaymentMethod {
  id               Int      @id @default(autoincrement())
  name             String
  // PaymentMethodName             String
  cardHolderName   String
  cardNumber       String
  expirationMonth  Int
  expirationYear   Int
  cvc              String
  saveBillingInfo  Boolean
  user             User?     @relation(fields: [id_user], references: [id])
  id_user          Int?
  Invoice          Invoice[]
}

// const enum PaymentMethodName {
//   CARD,
//   PAYPAL,
//   APPLE
// }


model Address {
  id          Int        @id @default(autoincrement())
  name        String
  number      Int
  letter      String?
  block       String?
  staircase   String?
  last_update DateTime   @default(now()) @updatedAt
  users       User[]     // Change to plural form to represent many-to-one relation
}


// NEXT-AUTH
model Account {
  id                String  @id @default(cuid())
  // userId            String
  userId            Int
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  // id           String   @id @default(cuid())
  id           Int      @id @default(autoincrement())
  sessionToken String   @unique
  userId       Int
  // userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
  // id                   String  @id @default(cuid())
  id                   Int     @id @default(autoincrement())
  credentialID         String  @unique
  // userId               String
  userId               Int
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// TODO POSTGREE
// model User {
//   id            String          @id @default(cuid())
//   name          String?
//   email         String          @unique
//   emailVerified DateTime?
//   image         String?
//   accounts      Account[]
//   sessions      Session[]
//   // Optional for WebAuthn support
//   Authenticator Authenticator[]

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt
// }

// model Account {
//   userId            String
//   type              String
//   provider          String
//   providerAccountId String
//   refresh_token     String?
//   access_token      String?
//   expires_at        Int?
//   token_type        String?
//   scope             String?
//   id_token          String?
//   session_state     String?

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt

//   user User @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@id([provider, providerAccountId])
// }

// model Session {
//   sessionToken String   @unique
//   userId       String
//   expires      DateTime
//   user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt
// }

// model VerificationToken {
//   identifier String
//   token      String
//   expires    DateTime

//   @@id([identifier, token])
// }

// // Optional for WebAuthn support
// model Authenticator {
//   id                   String  @id @default(cuid())
//   credentialID         String  @unique
//   userId               String
//   providerAccountId    String
//   credentialPublicKey  String
//   counter              Int
//   credentialDeviceType String
//   credentialBackedUp   Boolean
//   transports           String?

//   user User @relation(fields: [userId], references: [id], onDelete: Cascade)
// }

